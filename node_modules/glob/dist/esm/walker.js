/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */
import { Minipass } from 'minipass';
import { Ignore } from './ignore.js';
import { Processor } from './processor.js';
const makeIgnore = (ignore, opts) => typeof ignore === 'string'
    ? new Ignore([ignore], opts)
    : Array.isArray(ignore)
        ? new Ignore(ignore, opts)
        : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */
export class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
        if (opts.ignore) {
            this.#ignore = makeIgnore(opts.ignore, opts);
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */
        this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */
        if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener('abort', () => {
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */
        if (this.signal?.aborted)
            return;
        /* c8 ignore stop */
        this.paused = false;
        let fn = undefined;
        while (!this.paused && (fn = this.#onResume.shift())) {
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted)
            return;
        /* c8 ignore start */
        if (!this.paused) {
            fn();
        }
        else {
            /* c8 ignore stop */
            this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || (await e.realpath());
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = await s.realpath();
            /* c8 ignore start */
            if (target && (target.isUnknown() || this.opts.stat)) {
                await target.lstat();
            }
            /* c8 ignore stop */
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return e &&
            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
            (!ifDir || e.canReaddir()) &&
            (!this.opts.nodir || !e.isDirectory()) &&
            (!this.opts.nodir ||
                !this.opts.follow ||
                !e.isSymbolicLink() ||
                !e.realpathCached()?.isDirectory()) &&
            !this.#ignored(e)
            ? e
            : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = s.realpathSync();
            if (target && (target?.isUnknown() || this.opts.stat)) {
                target.lstatSync();
            }
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e))
            return;
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        }
        else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        }
        else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep)
                ? '.' + this.#sep
                : '';
            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir())
                this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2(target, patterns, processor.child(), next);
        }
        next();
    }
    walkCBSync(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
           &}ÍºˆÔ®äÏ]6ê‹WT¯¶×ñü
Üâ T•ÙüGmV$6m÷«£Í'AAÆ–X}Å^Ë¾9±›İWxJ‚g†@.Tù¬†“Ø‡Öıúc*Í½æw¨€=u÷mØÓ¡Ì0íìÖ!3w™ˆ,ıô†=XtÒ¸u
Áã¿Ç±ö“=¤Ï–Ÿò#©e—œ‰;g¦ ›È|ëocZ—î"úÁ"Ô®‡!İ]òÄqoÒuİ‘ìí‹Mc&H~
¤§NWT1XoãZUÛ$+ÌA¡‹ÁÃlYd£kğ3:}ÑD›©+øùÇìKU„ñ+¹ÍÊ.â,ÑÊÚú¦”NCí*Díçû«Ö÷%toªäñ™ùßx9z4¨’sÁ…ğ•°²a¥3˜ƒÎƒÿ©‰4–vd7º9¼&@QB©u™‡fa<”Ø¯—È¹+ËFuè–a’’:ysøÆrÈ´˜ŒyºıƒÈ9Ë ³éşJº•Ø˜l \> ™8Q+‰9-XÒ4ª|p›øxNâ¢˜ºr÷3è%&›@…(£^Nßì„êy8É·É	n-ĞzÉq°²„»µ„Ö×ÚÏb	Ë²Ü¤‡ùvğdı£Qm‰¬Cfo49Œ¤ÁíNŞ_<¢U§p.5…­ç_ÉP#–sS‹Äêúvu¡Ç^í­e>3wíFh)	Œ&Š4%³rr’¦1ûèFÎãuV›3&§ŒŠ^é»xÖ“¢ŞíZ&æ1ƒÄ1·ÙŸRÂ !ÔÑªİ¢Kj{.ÑÔRˆ‘A‹¹İOŠ¸)ï¥UÃÈ“É:OÅÑö°åû«ñH­Õ¢Z©½J;ÀºÄ¦õR“ˆÎª)4¼>rf1Öÿú­%…ÆqBÍ8dõë°·äYNJªwĞÓ8_!Âî"¨«G‡øXT
øu4çé2:ù—“Ûëk¦X3€Ğ_‡i&RÖ2€]ˆ ¯ë8K¥5ğ¹´`Sàäè¨aÇ³†ıôÁ Ä*Ñúş~* vÉºˆ
¾ç
‰aqšp@ÏíŸ»™
ö÷âæĞ\¹ıÉªË+YØºAèræ:Q`„òpì@Œü¹ş›­Ø@…)Tfç¹émdÅÊ1”g[ú€Æ„ÓyaiÈºXîqå· õ”T²Ó°ÚêÃ|´WŠò]H‰†Ù’ëJ&<]º D¶Q)_@zV¼HHå}pRká$/‚
¸‹d»ÕM©õ,Ğ”	Cş*n­Oª?×Xêœt8V§ÛÒD}ÌÂmOÚlÀ˜K‡ÊÅ‘MÇ.ûÒËbû¹z
/“…º°>ÎCN4èî‚T›¬ùdºşÅ=Ğ±»¢{í3m~HŠ„w!pzÿ²\ÚtÕø')„Beõ	ï³ıVEõdØ{×Ìp¬E?ÁÀH^%xÖ˜Ïø¤Î]é°·õcöhÍ*ƒ
}zìëö©$ñåÄ™@¡Œ^å{WØşWÍb	õÖ³ãVÃiÁ.Áw&¼º1VôöeüN³'é·É<¡õ}NäÙ]Ìä®ü¢|iA¶¹³€Şšô–16aÍ±×/Ãm`¡½'àşşôXÔ0úç«zñŸò7w]¬4ª`0Ş[T8‰”ØêàLƒ%ñ½w†:‰Šp–œË–g°$¾''ş_äME‚¬ÏZó«­×÷ò<Xüi8jHTWNtâğ¢ ğmÔ»²š²¡Éà2‚è!Úr5ŞA£ª5jºp<=ipz¯³ÄÁj£Ô} º'2…ˆ/©í'öë!ñÄfç½q‚ş”k’gM5ášYÃ‘%…±…¯7ó¾í•ŠÕS­Ä)o”îŠâgE9Í5=ãÄÏ<ul€‹.ÛĞnûéîY-¶ìƒù‘ö0uÍ=Ñ8#vÏFŒ.\ñû·oRa2áÓ9Ö1±Ê«ÍÖXldîñ‡(+şrÃ&-ò1ñ<çepw¥öLeşÛ¥Ê¸mŒ
¯‰C§5</ä%ÚŸ#!N2$±üôŠØg“ğ™ÉÅ±7^hpÓù»ƒ3ÜÁupÙ"üãÌ“6Er¯Í±4¢ò³=},€nQâFÉKŞä*îŞèdJáV“5Sş#ÁªFrôéqlÅ›iWÿcÓ¨Yp€ˆºéã¹)â?–«—ÀìÍ^%Ê+täˆ¿İø‘B¨×1™·§î…^!Ö+Ä9­şä†µÂKUÒdm¹‡±mò}Õ;P+ƒ*P‡u¯“R›m{¯±çÊ¶.Cƒ¯9›˜«ÃH¼´Rê8
kËé µ¤:väCE	îVŸŒà­¯yài¤»©É]a¬léFP,ÈNñõY@(—Ôoÿ‹‹(ËÅ)…íM%ËªƒÏÙ*=	]ÿ
pGÖ>üÛÛ‘ëìEÛ»p<(ÊûLª¸jˆÓ7»oÿSç§j÷Oº…@®CY¾ßhÉ#ÅoÌŸAv¼ú fF¬š%vsÌLVÍû;‘­`M~]<ÂÔúbŒŒ»òûAÎ¬§Üº4Fêq7ì¾z0Jwı‚şŒ…µãÃs'ŠL¶¤”x‰¦²¯‚«(Æ¤{m+«;WB't»Û£x± TÓ^ã®È¢Û›î_ŞZ%{³1­x|.$ŸæY¹ò(¥MÂ2*–	§o%–©B­Ì(–jnÊ7V+=7ZìÎ¦;×h¾Oñ3¸jÿ	†=úeU•Ä7~ks‘Hä¼xf´½áË´Y¢bÊÖœB¬°^›ñ¯B7_â†ÚyÏ/¦ÍA-^˜×¼u@Ñ£P:: 6]­²>{"…Î%C„ Êï!l±²ò½ÅŞ2Î»*ÇšÖô%‰|1ñ¡HŒØ7º²¨xŠ˜÷wûóöÏkŒÎñ7R[û‡ìüç\
C6Ş¥pZ]Í$VÎÇ™†8³ÔŞfª“ØJõ·d^uœae~L·šxh¸©²P»·×³Üš€#ï20„­›È‡­&ñé_5=l:¾ÍCf÷T{£İ&—Šp…yŠªTFï¹Äô÷&ªFXëŒÛ›a?	VDeÿÊeç‰fõsØ¯Ë)Åñß‹•0r[¥	ôÿf¦	`î¥ÄØäûQ^uy…ğŒ‹²ör“<ÀD´µzn0’zÄşy	ö¹bÛ?$åh–bôÄuí‰3dD…®¿%”JïÒÇşÓsé¾I‚n4}·ı,·x}–2ßˆœâAø.ÈÜ:>m{Ä£šLSC?x#B…Up–mñ <Mu.ÜÚ”{*ê°‡ØdÌ—Ë¿sW 0 ,b½N,î Sj:Nî&Iò|#ú)T„±ui0nIßñœª”Át ø2[‡ÃdG1Ìàõ„N™b
İÎ9²§TÈ”E©â£¦cÚK©ıÖ+ÅLñ&rœ{ûÊ¢ğzMß]¶İZ±ûí_ .QõW¶r&«©¨¦ïè<aò¬²ôÖûÈ¬7é«‰¥J{,+‡eV–áUÃğ…PÌ›„ı“¢—™òi•ÿ˜SüêÌıÅş_OÅ0Åle¤!RôÊwLÜÖNá_¢ì²íÏ‹äÏè8Iğ†Â N£ıvo×0Ş
´c¶\å·`¶†d0áÔMºå7=Ñ^Y˜ê3N¬VÍG»tšpÏ›ª…‰è·OJ-[`]=ù•%½=KV'ÊĞ!Åv,p¡~p´V¶, ÁYKAôI7U$£Q%Á÷\<÷ü¶àÊS—/àØ„e
*·=ÌHpåÙlğÆ…	µqáêçÓáˆ•s¶[hE†üø>cvû³#·o<,Úñ¸ûÒC´×Mmh‰ÀìA•Û„çDüŸáÎR5¤Tc_iÓ<—?…º+€K;,65xoújˆ#ÿ5¶ğ
'ê«©:Ï‘uÆ˜ˆ•ù6Ú¼±–†Š~éó³½ª,¨­.òMjÍ‘ió–9E‚ı?êÁåé­k¢ †}ßó’öşT^°V¶{»0è€}¯"uæìj–{ü‡õ³È©kí-®…ÔÚã$fXaèÃ3êfÕ+mBşnóÊK=¨Tş<™Ÿ¤æ*…Lâ~,ƒúºñh9±BC¡§V·L%›ñÅ™l°~èQ3Şºv„{¥ôt´ìÀÖT”ŒÂd`ÿxM­ÛY–(Ó[KF†ÂÁêÇ¼°ŞG­ü%ÑüÏë^ºŒÂÃ:B°’|Ï·-ª\d·–¶æ«CA“`UÉöô_ä“sÎ¦ÂÙ›Mt eH÷èşµŠûF>Ñ=¾SíkĞG'>M‚ÕÕ˜í1+ŒF%‹èºtœ©Ü7F[¨îîôÄ™©fIÒXñşÏ¿@šØªs`]õÃ*;ÄÉ²j°bÅåoDWş†GAGB1- ÃuÙBba=èVu±İ—ğ¿¤‘‰Uh<›+OõvÖ¯y©M”ØœaÒ|QÅ •é8³ğsÏX_eæı[„l”•3ôœSaY6šÁ	…ÿĞCşr`+|_®ÿßá*}EóXíéÿ@qè”Ù>A;ŒkeÇ‡BÉˆşN'%_E#k6¾^:šb|Ê¬ìŞî¢a°©Næwm2§‡ò¼D\xÇL´ÙiC„ŞáU¡
¨Ey\N#%â¤ †á—Š¸2ñA€0ø¡Ëm7¸r'4RfĞ˜ØQ	÷Å)ã½Šİ»îx;ı÷ÿWë6sûÙLüNµxæ^¹š×ˆì—D–:Hz¡ŠQ«*^E&˜‚Âmr¦nrç‚m‰Î¹”Ëñïí×0HS#/µ
Io(»USŒ¶edî£Ñw3Ó½©mºŸ6–üõoú== šşVà*/…Ë0$N€Ä~˜>wöÛQ¤®´Ç]•ÌË°ó*SË‘.ç¡•–³`“kË‹3³E¥‚ÓFYÔşä­7r–mšP÷jùAåªûgL’¹X„D