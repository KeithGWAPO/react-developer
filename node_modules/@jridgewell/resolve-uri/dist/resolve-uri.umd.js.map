{"version":3,"file":"resolve-uri.umd.js","sources":["../src/resolve-uri.ts"],"sourcesContent":["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nconst enum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first ©t´á¹÷Ãå\ëşXò Ï2wåƒ®Ü:gå‰ö)[/Yó§¡€Á…èªÈ‰ßÔnK#‚VÓZO&¿D÷
3ÎäqÜ°¨ ­Ëh¨FyáåÎ‹×˜ÃsÂç¢©cA¢Ë1Lå-/¼WİÕ¿‰¼º}ºU§ÇRÉÓ=€ì2{É´J‚„üa´)-_g{úRä´_â¦yHZ¡™Çrù [úäU‹«K¤+å—Vá;|ı(VØœÇôF6À©;×~ÁB¾irªÚËÄÇ”èß7?Kï"_“eê#CØ£€¬H–wksàÁ\©.äÈw"{*rUŠK¹n“6üüûD4İá«¹å‡k£ı{!3W~¢Vf
9 ‰ìú#dTTI¤ÅÕÊÄ¯ëyãÆËïíe9Ô¸–;ÉKŠP¸¿Ûl@ªuFãÊäwç¨8uĞV)ëuæyÖr|€õ24ÈÙe‹…0fĞ¤Ğçğ~s7÷³–‘‘ù%à¯&£ça‘ë½Ù¤¨¯?a^sÑ
T:©Ü ¨ÁkÆßa#™šÆòDß(%=IZó%š•)ï´	X<Ê£ ã¾^rãƒç©†;2FÖÕş2«ø±k‰úäISÎctÈ,¡^}ş¯‹_º>|›¬¼ŸX¼SÅ]/¡·\÷a’™ñ®:$…_X¥¡¼š=VŸ¾“ŠâE}/ÖĞ.³øTú÷éóIAóùƒJéfèŸô•Ó·<¯8ÕŠ]	ŞÂ‰Ş²‰3q9Z×ÆØ·oE=j!l˜şÔ‹É‹Ï[pİp–ëw8ıe•¨ \J İV©¢GÉüÎ/ÛNXÍn†sæÜsmu½×¯'PN?Ù‚?.@P›áEPGSÕRrÃA”šì|”İ:wÙÀÕâôzÄ»J§WíÃzœÁÙ"‡Şè9QrVVĞÇ­}5‡ı•z¹™£@ëNIOÔùÑbä­•í/	Åmoñ	İúH¿,¦TÈ®~¨È³8÷²C%ÈÎÚ¡­—IR0±İ*[K•»ùIÚ@¦Éü¦¡‚÷cK6ğ$Ïk!Ùˆ×ñ5õÃ):üD­:Ÿú+¤7z¸@‚5İ­ÃµkÍ`…Ğ!å·ÌzÂ²ü»±"m„&ÉØ¸Âô< “Ñı‹.è"ªùsÿ5ô’¿é¬.¢â†¾)¿ÙJ=:³|ŠŸZB/Á=ÀÓî›	Î°«ÇA;ˆVÈè×“\—«ymòGö»QC‹§¼X¢wƒÍvôy99ÔXbëL±üÓøl®ÃÌ¼Éô”bj¤
ŒnZá9îd|^|$Ò]I‚ô¿u)ÑP0Æo×cğ©vˆQ?ÿµ§;~×[W˜~Fa¤›r£ïøl—â.2êK)£šTõºÿC±ÄÒãYmfş»ê7Sâ· W¥ùV5'ù©LŞÅ/˜é/'ü¯QÂ„#³®X†¢Ä; ÉÇ5”@TÆP¡7'‹ÿKÂÅ5ÈÓ<¼dÀí°İn<Õ|œŠ»ø¨¶¯Š¢@ÇÛ¦ ×H3ñ `§Ö¥o‚é,–,Ä&OrbÚè.ø<6™~R-7œ‚{RKîB_ É‰£($WÈNÊ~ßI¾ªCò/ÃÍÌ)µ»ÿ‹­†ÃÎµx¤­Æ õ:i(…÷ŠíC9d¹Ù¶3K~9”Q‡+Ê Ì{¸]š‘wBŒE/jŠß¬—[S¦aB’‰]…“ÆCUışìf#ß‚AÅÕ²àª¿ˆ;8_pW®¸1Şá‘8.?İ{/>İ[0»‘ñÖc4SVnr'+£ÖKÊ%ˆº7éMÂÈ´>ÏVU	õX„Îôhtl1õQTáékr‘<9‰ñÀËË•«½}6pÆÎåH*¸¾ÃÛ“ş‘»yŸrÕÉâÕ
‘‰¦çÅÏšêñÍ²Éœ¨u^~ª–Y‹Hlu<D›èçØjæíûÄúŞ©hoa¼/¢“ğş•Ps;r¬ƒîƒŞX8£¨5ìæğ/yÃ®ˆ?Ş×íN2ooÄä'D ğô	¢Éq=Ì(·O–§øÛÆ•Jß"€`â‚Wf Au5]
ãõ’3í½pd*{ÂÛİ¦V)´äíı/µŸ¯P?¾'Ãq1„öÙ.¨Óå¢‹À=6)f`37O8ª)U‚=z’1_w)Â+§¿It	#âs~«f_$wÍQğ¦b?,
Ç šÄ;»ÜWÿDNßgî9±ıo^¶›óĞ‡ı'”3+ît=xÇ»ôª_óú¬à9Õ ‹¬g2aß²UŠÎS›é=x¦ãlõxİ0?M´@Bj[ic.û1DC¨ì šùøÚ_ª´m«ÔTñãÂt vš×ƒ¦Bjp±SÀjÚòÚè ' Ül–G˜ırëÖÀ-[ĞéWzğÌf,# ³†"Ö¹l*9Ff}©Fv–4¹9Ãdù¡ŒZŸŒÜéßQ ’4İ<ßÓ#?­	£T_-ŞÔIÙÄ0Ò;•42Y\êâa—Z×
èÈÚ$.İ¥:€Ù?Ş'BÕKJU¢O¿&ÛÄIíBËÂàõhõF)¬ÆßE•UÊªÔ’ÀqàñVè„`@ˆ·ñşÜƒ†P ËW±İÌ7å¢\Su™hCM§`_ÓwT¢¦2º®Æşb¤Ñ€x–wÃußˆÄ½½JWÀ‘ã$unìv~ï·+–§ïM´*³O­Vï®ìé]™Óç‰å1~zE!u îÌ[²²_t<(€£</ºh~k<¿€\á‹û‚Ç¢d—
^× Ç©ç”¶–QÛkh lê8Gõ,h¶-Uëj2v»Néù-x Yıó8ÿ×:AsˆF+Ğ•Ñp›L\n„N3RåÏö>.tq3xHÃV©&Ô÷i ¡4×ë(4¥;³ÑaòG{\Dım&£Ê¯#aŞ`©Y¡+œ½ıjGºç]&è6¯Õ6;¥j¹,‡PZxÀÖK¦‚)áÚµc9İ®—/Ÿ°©àûdZÊÄ)ş>	)*Wd^¯µhEæ9ûÚ@ÀğÍ²[„2U* ¥{ê±÷SÂ©¡=ÉÈO\ÁÖªyúïŸH’¡º‡–¨ƒÌÂ½îø¼uçQÖ²†à_¢D"
=‘H“^Ây¦‡^5&3Ş*3ì4qÅA õ$N½‰,Na®_êšn— ÷‚Ï‰ĞLX˜’ğÀp•<d¥õtñ §FöEÅ˜ç‘Õ°,Q˜©Å2+K	8ãb–ğA“›o2Uü·8%E âÎ.á§JM¼w_ç4ôBOc¼B£íÿ¡ö| ®ÈÀßÂb(qPBª^PM/y­kIWWñpm^Ú zp.°‰]ß›_ƒ½Ãù‘[ÿıŸ5ÇGû•×-0™¸T‹ıÓˆrš¬FÂª~„4•ï=HNäï¯‡a®*es;ôv–Wå†wîê.86fá®Op®Éz]0†ÕÙ‹—D]'/ç=Z¨Õšã£Pê)Se7Ì5¬[oé‘p:j12µógõM˜\üâwŞ€ãA£ "PŠgn	âgŒ~İ(ÇÃE‡ˆW’ÓÀI&ãFœ«%„wuÃàwÈpØS€Šîæ8`O˜ã/9öhÙk2pRÉ·®rjÛg‰†^i46g?¸ù¾*yöpco˜6r——_	š>e-cv›Éæ3å­¾ò\¡sazù—T•9PäuËRSeÂiÓÎíßuÙ™eúÚzgëæĞ%8¥±^0tZ Pñ7ö6)E»ŸĞõ„Œøšß9%Å½@­§@¬Şœø.…n‡P?`­…ó&êT† A=ÆÌÍ®õŒfrÙ®—6ı–1æúÛEU‰â!ñ­óš>7^­5qLzû¡´V‚ëX ¥ìp»ÒëSÀï> _Ê§:µ®£\n
Èor¶¶Ö%€kIÎ‰F¯¾á§÷w¿„Ã9Øç‚ò•.qÂÏÑ©pM"GcÏ0Uè`æAãOÑ¬‘ˆìt¼‹+ˆÊ²Ô2—`×½ĞiuÁf€ĞÌ’²vÒLt*ƒ¼oÄ—lÈ£î7yC;Bx‹È~Ñ¹ã$.Ë+OÁ–ÑG}ÿlsìW±yíYêâ¢•üvÛ&J=¶L÷ë<ÙhCAâwË²ß¸»l;\âÔØÊ¸Ø=Áú{±í
ÚÉ!¶×7€‹§ªbŸx·\V7æªçsFI±8‚wI…lƒe/øq½»;k'NXcå@ñvÖş¡,¡¼8¥M4I–§=o*¤\¨ıÀç%d ”Œeâùê+'›d3ÃÏ¬®mÿúŒUËã#•°È˜Ø^|1¼u˜î²Æ
šÍ·u¿,¯G¤¡À—kJÆó·D‘ˆún¨8Wd·væÍÙ“‡q^²Xƒâ¬ø¶ü'~^xípù¡®ï"nÄ4­awÙÜMÓbÌm1ú±æAÂû4eÚ>ÛZØ¸£tBhŸØˆG0è,ÊÜg»¤/oIU¡MbiŠWÖâæÛ* ã6R¹ì?ò%©¥¤ı)Ï‡2$757×ò¤Åë‡Cí‘%q²§=1cÎ*•Wà1áB»ä€±Èo`|{ïk®3³êœ´&3Jà½	öW^„›¹'=£< çå¬pUA€ŞC6²î˜­L1,n½ É+:•‡ÃZ_Ø´KZ‘qVã´‘wzŒ›Z'?o0#÷Ô·lw©Ü¹vş›ZÚ¢Kµßì‹ôøA;y¡›.VÅŸJ»~RÛYÌôS³ˆÍ×„)$$š`ÖF2%á:¥‰!­Tòu²ó±2r8ÎEºX×úÖ¼!Æı´*ÖlĞdı^’IOJ-€ï„< î­]¹Yô¡R­«Ôíò­½Şqã6}«w\A”¨ZÇ¡Pæoµ‰°CP©h?8<`œÇ‰M/üˆÃ!}Ë¶ECì	Ï]eÛ·¨U$ÀyÉÓb9Z?™\›†ãƒ ­‡EÖFg,®Ğº.Ñ`R¾¸;Ÿ­¡$êù‹)üìWbƒqú1‹MxAH
>8ô$?½˜<Ê¤ã	9ò)ğUoJéª¶éÄYéçÇæØÌ@ˆ ryNÊ¶ï~Óñ!Æp7Í—=Üß'DT;ŠùãeÖïÕ¥îÖ@ªè’¯‘¹$6ÕO˜UÁ2çQ¿z#å×°]2Û6&¯î°r@%ƒ²Ş†iÙ6˜jÎŸ˜–Â¹g'8õÕƒ/ş×±¾E‡²EFg{Ò	d*]†kJ¥ºùéfHu&t"2lá.İ:	eÄ –BÂœ²6ú£á<@Q¶fuË}iwI1çİ S6Æª%i9Fé|rRábW­…mm
]/«CZ7°R¹dÛŠù—…:Géü† Œ4“6HDw@s.ø5’ïßšñX˜9<Ku»—Edî3Xb`ò×Ï°ÚAŞ>y=è~–øÆ<fu¥»ï²ëy°Ã¶ªEşFî,ˆ…;–;ÁZY¹ka;©;‡QlÔiá|ĞºT¹˜SNë­³Š„ËmÉ è+8«¥NßÄ	®*Æ<:GôÂR0Q‘ˆ¶kä”¾ÏÉÄ
F€¤QLi·î$lDR‘ùnŒrÂbü­§p0şÔÇçF3èÒ^¶‹ˆ1¯fG&öß9ï[-ŠZ3FÊ.ˆ=$Ø€Ì9úêà>ZŒæENó(3í`‰´ü–ê´dãp0^®'!ëê`î²pİãF'¡]×5Ã+ÖüïHYÚO|VÊˆH æ„”âkÂ&×.Â`ê¶)X*>4Ç)s³)óŒU–‹¶­IŸFúê	§•Æß‹*Şr™—êêèWæ+ïÊ¨™±é¥HØ-ı±qAİüÙj“[@ÌuY»5Ifat$¸\¢¡53]9
ß÷¶·%íòâïÒÇ‘*1&õq†Ã)Š)áœ»á@*%m'ù,\|hBÂóÒï²åvp6>,Û¶]ÊXóçğÖz¬×k«»3$õD@©ŒËĞ›™;	[ed„Û×ı `ŞZhÖ†¥.…Äv¢U\›öP}6,°~—ìŸY£b!¿sä¥.ë‘é¾«<4))¥áÏìtŠğf.üç<Iõƒ:å4Eö)K'}qŸĞ´±C§•®š%Š*ÖzØ|ìTP"Éê!ÉçU5O 1–b~@VoJFãÍA„U°)¢[ËgÚÌç¨‘) n¹Ï—€$©Ê§p‚eMÓ5T„Ä£yµã\ÛB+§‹Ïõ‘¶v	Æ{B½†5Š'æUÒ 28¨½äÃ-`Li¥/F—»šŸÛ¸³e|®”}LÒØŞ’Ì{|m=¢!n—vı‡Ì€ô[-±ıÑ^Š—ƒ‰*x¡ÊÄå4k Ÿ'Ç^¶8DÂâVfqXÅt”ÁÛaÉÌTHS7NÄ’›fz@ı|äS4˜¨UÌÃKîôŠêåbJA€0Ç¨U¾c2
FI¢Ğ×†ŒDµÏ,¡=õé¿ôjğr'²	»;–n‘ìàvıüåé}§OR6o¹›9àk‹™­7cü³MóÉû!Ş6É¨ªíŸ‚9W\iI/ïKp  ³êÖ=„MZ´°“DYíR÷²±ÜÛÅMl@ğØ|ƒ.9~aÇ^0›PeÚq½MJGi™XŠ97€•Oük‹,«Ô
¡23T>È[*zÑvÒÑaÕ•Ì<bBJÂª"1ñ=UyßÓº2‡lE~ƒq ¹´±
(SƒÑ–ôğy™±øÉ>|GUaˆ¦Ü8ó²YÑEoj×r§¸ğÎcæNG³,qd£­åf+É×¯‚nRÂpÉ!Ê­ùÂt¤4;k¢±Ü#çjÄÂdf§w÷Zb÷ş4äe“	¢‡t’óÖâ›à X23{MÓæ(êÁ®öĞ¦3ôeMàÅ†ê‹qŞ¬ŒâOéÛ~úM«êŞßøi`j&æç\ãõ|Õ‹_b’BŸ“â3¿5ØÊ.l×És1êˆ!4H&Ş¤.Ù6Ğ8·Q+ÜœgNèº¢~ÿ3p\|áÔ“§â§ÌÅaz]¥yÜ°}ÆĞ€¼jñhƒ¿×ƒ+ô¬:Ô*x®o®'òeLô¸­V‰Uí%¨š¥…,uÀàĞ¡[üÍÔ5-·ƒ0rY0‹AUpšß9Š°(ÜCEÒ¸<Mÿgz'E™P>ÚÀ£ÙkÍ\Q#!ú“ôãÀöÆaöÿÓ¨Şœ©üK¬S9÷5¶Ä¬–~ô§Á½(‘7‘nT—† /€>ÍyÎ@øÖ‘hWG—ß»bŸ?0«ıaÄdìXœÊ[vÍf”I{ |PÇÓ4#Å?İÍüí,èŸRıVWª#ÓÕ1¡OÀ¯wÛr°z³?gi"G÷ã¡°C_
]í).…S] *ô¢æZ&ÑO°Uª‡/(Â3Ò8½rqìÂ±«×
ZáÇØºäëjŒ`^”`:˜K|mJ0wåãs}±ÍËfUSuıÃq¶A_¤]‡g*Ö´8V3ŞáGñ‹Şn‡YqmJşäı•ŞØl’5á_Cñ¬XoĞ©‘«På7oGTÁ›u›rƒ40Ö’8iêàıó:ˆ’—PÅ^éqşZfrfÆ´‰ä°Ñsrëvß6ıpDÑHÁÂ¹.«)ò—L’€³@L—è„¼eû.c½ò”jí¢Ã=›6úJVàTÖ3n$Q}ƒí$IÎ…@Ã¤jNßÙÈ5²Î¨×ĞKğV-¼›¯–s'%°1wG¾L¹Kk¼¹MLOø7^bƒ”[©5öG”»ÙïHh¤ãMbÎ	ÁŒnŞ
mèS »Ğ:ˆ°6+@ôwÃ·°ñ@fÎ.GâOÁtdnárÈíé}­MCÓKûµ¨˜.ú¾nñCŒ”ƒ>ŒA§òìVb!]ãBº‹´f‰ 7Xó‰tp^˜â ‰Õ4gÍí¢kIúğ