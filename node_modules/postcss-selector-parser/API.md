# API Documentation

*Please use only this documented API when working with the parser. Methods
not documented here are subject to change at any point.*

## `parser` function

This is the module's main entry point.

```js
const parser = require('postcss-selector-parser');
```

### `parser([transform], [options])`

Creates a new `processor` instance

```js
const processor = parser();
```

Or, with optional transform function

```js
const transform = selectors => {
    selectors.walkUniversals(selector => {
        selector.remove();
    });
};

const processor = parser(transform)

// Example
const result = processor.processSync('*.class');
// => .class
```

[See processor documentation](#processor)

Arguments:

* `transform (function)`: Provide a function to work with the parsed AST.
* `options (object)`: Provide default options for all calls on the returned `Processor`.

### `parser.attribute([props])`

Creates a new attribute selector.

```js
parser.attribute({attribute: 'href'});
// => [href]
```

Arguments:

* `props (object)`: The new node's properties.

### `parser.className([props])`

Creates a new class selector.

```js
parser.className({value: 'button'});
// => .button
```

Arguments:

* `props (object)`: The new node's properties.

### `parser.combinator([props])`

Creates a new selector combinator.

```js
parser.combinator({value: '+'});
// => +
```

Arguments:

* `props (object)`: The new node's properties.

Notes:
* **Descendant Combinators** The value of descendant combinators created by the
  parser always just a single space (`" "`). For descendant selectors with no
  comments, additional space is now stored in `node.spaces.before`. Depending
  on the location of comments, additional spaces may be stored in
  `node.raws.spaces.before`, `node.raws.spaces.after`, or `node.raws.value`.
* **Named Combinators** Although, nonstandard and unlikely to ever become a standard,
  named combinators like `/deep/` and `/for/` are parsed as combinators. The
  `node.value` is name after being unescaped and normalized as lowercase. The
  original value for the combinator name is stored in `node.raws.value`.


### `parser.comment([props])`

Creates a new comment.

```js
parser.comment({value: '/* Affirmative, Dave. I read you. */'});
// => /* Affirmative, Dave. I read you. */
```

Arguments:

* `props (object)`: The new node's properties.

### `parser.id([props])`

Creates a new id selector.

```js
parser.id({value: 'search'});
// => #search
```

Arguments:

* `props (object)`: The new node's properties.

### `parser.nesting([props])`

Creates a new nesting selector.

```js
parser.nesting();
// => &
```

Arguments:

* `props (object)`: The new node's properties.

### `parser.pseudo([props])`

Creates a new pseudo selector.

```js
parser.pseudo({value: '::before'});
// => ::before
```

Arguments:

* `props (object)`: The new node's properties.

### `parser.root([props])`

Creates a new root node.

```js
parser.root();
// => (empty)
```

Arguments:

* `props (object)`: The new node's properties.

### `parser.selector([props])`

Creates a new selector node.

```js
parser.selector();
// => (empty)
```

Arguments:

* `props (object)`: The new node's properties.

### `parser.string([props])`

Creates a new string node.

```js
parser.string();
// => (empty)
```

Arguments:

* `props (object)`: The new node's properties.

### `parser.tag([props])`

Creates a new tag selector.

```js
parser.tag({value: 'button'});
// => button
```

Arguments:

* `props (object)`: The new node's properties.

### `parser.universal([props])`

Creates a new universal selector.

```js
parser.universal();
// => *
```

Arguments:

* `props (object)`: The new node's properties.

## Node types

### `node.type`

A string representation of the selector type. It can be one of the following;
`attribute`, `class`, `combinator`, `comment`, `id`, `nesting`, `pseudo`,
`root`, `selector`, `string`, `tag`, or `universal`. Note that for convenience,
these constants are exposed on the main `parser` as uppercased keys. So for
example you can get `id` by querying `parser.ID`.

```js
parser.attribute({attribute: 'href'}).type;
// => 'attribute'
```

### `node.parent`

Returns the parent node.

```js
root.nodes[0].parent === root;
```

### `node.toString()`, `String(node)`, or `'' + node`

Returns a string representation of the node.

```js
const id = parser.id({value: 'search'});
console.log(String(id));
// => #search
```

### `node.next()` & `node.prev()`

Returns the next/previous child of the parent node.

```js
const next = id.next();
if (next && next.type !== 'combinator') {
    throw new Error('Qualified IDs are not allowed!');
}
```

### `node.replaceWith(node)`

Replace a node with another.

```js
const attr = selectors.first.first;
const className = parser.className({value: 'test'});
attr.replaceWith(className);
```

Arguments:

* `node`: The node to substitute the original with.

### `node.remove()`

Removes the node from its parent node.

```js
if (node.type === 'id') {
    node.remove();
}
```

### `node.clone([opts])`

Returns a copy of a node, detached from any parent containers that the
original might have had.

```js
const cloned = node.clone();
```

### `node.isAtPosition(line, column)`

Return a `boolean` indicating whether this node includes the character at the
position of the given line and column. Returns `undefined` if the nodes lack
sufficient source metadata to determine the position.

Arguments:

* `line`: 1-index based line number relative to the start of the selector.
* `column`: 1-index based column number relative to the start of the selector.

### `node.spaces`

Extra whitespaces around the node will be moved into `node.spaces.before` and
`node.spaces.after`. So for example, these spaces will be moved as they have
no semantic meaning:

```css
      h1     ,     h2   {}
```

For descendent selectors, the value is always a single space.

```css
h1        h2 {}
```

Additional whitespace is found in either the `node.spaces.before` and `node.spaces.after` depending on the presence of comments or other whitespace characters. If the actual whitespace does not start or end with a single space, the node's raw value is set to the actual space(s) found in the source.

### `node.source`

An object describing the node's start/end, line/column source position.

Within the following CSS, the `.bar` class node ...

```css
.foo,
  .bar {}
```

... will contain the following `source` object.

```js
source: {
    start: {
        line: 2,
        column: 3
    },
    end: {
        line: 2,
        column: 6
    }
}
```

### `node.sourceIndex`

The zero-based index of the node within the original source string.

Within the following CSS, the `.baz` class node will have a `sourceIndex` of `12`.

```css
.foo, .bar, .baz {}
```

## Container types

The `root`, `selector`, and `pseudo` nodes have some helper methods for working
with their children.

### `container.nodes`

An array of the container's children.

```js
// Input: h1 h2
selectors.at(0).nodes.length   // => 3
selectors.at(0).nodes[0].value // => 'h1'
selectors.at(0).nodes[1].value // => ' '
```

### `container.first` & `container.last`

The first/last child of the container.

```js
selector.first === selector.nodes[0];
selector.last === selector.nodes[selector.nodes.length - 1];
```

### `container.at(index)`

Returns the node at position `index`.

```js
selector.at(0) === selector.first;
selector.at(0) === selector.nodes[0];
```

Arguments:

* `index`: The index of the node to return.

### `container.atPosition(line, column)`

Returns the node at the source position `line` and `column`.

```js
// Input: :not(.foo),\n#foo > :matches(ol, ul)
selector.atPosition(1, 1); // => :not(.foo)
selector.atPosition(2, 1); // => \n#foo
```

Arguments:

* `line`: The line number of the node to return.
* `column`: The column number of the node to return.

### `container.index(node)`

Return the index of the node within its container.

```js
selector.index(selector.nodes[2]) // => 2
```

Arguments:

* `node`: A node within the current container.

### `container.length`

Proxy to the length of the container's nodes.

```js
container.length === container.nodes.length
```

### `container` Array iterators

The container class provides proxies to certain Array methods; these are:

* `container.map === container.nodes.map`
* `container.reduce === container.nodes.reduce`
* `container.every === container.nodes.every`
* `container.some === container.nodes.some`
* `container.filter === container.nodes.filter`
* `container.sort === container.nodes.sort`

Note that these methods only work on a container's immediate children; recursive
iteration is provided by `container.walk`.

### `container.each(callback)`

Iterate the container's immediate children, calling `callback` for each child.
You may return `false` within the callback to break the iteration.

```js
let className;
selectors.each((selector, index) => {
    if (selector.type === 'class') {
        className = selector.value;
        return false;
    }
});
```

Note that unlike `Array#forEach()`, this iterator is safe to use whilst adding
or removing nodes from the container.

Arguments:

* `callback (function)`: A function to call for each node, which receives `node`
  and `index` arguments.

### `container.walk(callback)`

Like `container#each`, but will also iterate child nodes as long as they are
`container` types.

```js
selectors.walk((selector, index) => {
    // all nodes
});
```

Arguments:

* `callback (function)`: A function to call for each node, which receives `node`
  and `index` arguments.

This iterator is safe to use whilst mutating `container.nodes`,
like `container#each`.

### `container.walk` proxies

The container class provides proxy methods for iterating over types of nodes,
so that it is easier to write modules that target specific selectors. Those
methods are:

* `container.walkAttributes`
* `container.walkClasses`
* `container.walkCombinators`
* `container.walkComments`
* `container.walkIds`
* `container.walkNesting`
* `container.walkPseudos`
* `container.walkTags`
* `container.walkUniversals`

### `container.split(callback)`

This method allows you to split a group of nodes by returning `true` from
a callback. It returns an array of arrays, where each inner array corresponds
to the groups that you created via the callback.

```js
// (input) => h1 h2>>h3
const list = selectors.first.split(selector => {
    return selector.type === 'combinator';
});

// (node values) => [['h1', ' '], ['h2', '>>'], ['h3']]
```

Arguments:

* `callback (function)`: A function to call for each node, which receives `node`
  as an argument.

### `container.prepend(node)` & `container.append(node)`

Add a node to the start/end of the container. Note that doing so will set
the parent property of the node to this container.

```js
const id = parser.id({value: 'search'});
selector.append(id);
```

Arguments:

* `node`: The node to add.

### `container.insertBefore(old, new)` & `container.insertAfter(old, new)`

Add a node before or after an existing node in a container:

```js
selectors.walk(selector => {
    if (selector.type !== 'class') {
        const className = parser.className({value: 'theme-name'});
        selector.parent.insertAfter(selector, className);
    }
});
```

Arguments:

* `old`: The existing node in the container.
* `new`: The new node to add before/after the existing node.

### `container.removeChild(node)`

Remove the node from the container. Note that you can also use
`node.remove()` if you would like to remove just a single node.

```js
selector.length // => 2
selector.remove(id)
selector.length // => 1;
id.parent       // undefined
```

Arguments:

* `node`: The node to remove.

### `container.removeAll()` or `container.empty()`

Remove all children from the container.

```js
selector.removeAll();
selector.length // => 0
```

## Root nodes

A root node represents a comma separated list of selectors. Indeed, all
a root's `toString()` method does is join its selector children with a ','.
Other than this, it has no special functionality and acts like a container.

### `root.trailingComma`

This will be set to `true` if the input has a trailing comma, in order to
support parsing of legacy CSS hacks.

## Selector nodes

A selector node represents a single complex selector. For example, this
selector string `h1 h2 h3, [href] > p`, is represented as two selector nodes.
It has no special functionality of its own.

## Pseudo nodes

A pseudo selector extends a container node; if it has any parameters of its
own (such as `h1:not(h2, h3)`), they will be its children. Note that the pseudo
`value` will always contain the colons preceding the pseudo identifier. This
is so that both `:before` and `::before` are properly represented in the AST.

## Attribute nodes

### `attribute.quoted`

Returns `true` if the attribute's value is wrapped in quotation marks, false if it is not.
Remains `undefined` if there is no attribute value.

```css
[href=foo] /* false */
[href='foo'] /* true */
[href="foo"] /* true */
[href] /* undefined */
```

### `attribute.qualifiedAttribute`

Returns the attribute name qualified with the namespace if one is given.

### `attribute.offsetOf(part)`

 Returns the offset of the attribute part specified relative to the
 start of the node of the output string. This is useful in raising
 error messages about a specific part of the attribute, especially
 in combination with `attribute.sourceIndex`.

 Returns `-1` if the name is invalid or the value doesn't exist in this
 attribute.

 The legal values for `part` are:

 * `"ns"` - alias for "namespace"
 * `"namespace"` - the namespace if it exists.
 * `"attribute"` - the attribute name
 * `"attributeNS"` - the start of the attribute or its namespace
 * `"operator"` - the match operator of the attribute
 * `"value"` - The value (string or identifier)
 * `"insensitive"` - the case insensitivity flag

### `attribute.raws.unquoted`

Returns the unquoted content of the attribute's value.
Remains `undefined` if there is no attribute value.

```css
[href=foo] /* foo */
[href='foo'] /* foo */
[href="foo"] /* foo */
[href] /* undefined */
```

### `attribute.spaces`

Like `node.spaces` with the `before` and `after` values containing the spaces
around the element, the parts of the attribute can also have spaces before
and after them. The for each of `attribute`, `operator`, `value` and
`insensitive` there is corresponding property of the same nam in
`node.spaces` that has an optional `before` or `after` string containing only
whitespace.

Note that corresponding values in `attributes.raws.spaces` contain values
including any comments. If set, these values will override the
`attribute.spaces` value. Take care to remove them if changing
`attribute.spaces`.

### `attribute.raws`

The raws object stores comments and other information necessary to re-render
the node exactly as it was in the source.

If a comment is embedded within the identifiers for the `namespace`, `attribute`
or `value` then a property is placed in the raws for that value containing the full source of the propery including comments.

If a comment is embedded within the space between parts of the attribute
then the raw for that space is set accordingly.

Setting an attribute's property `raws` value to be deleted.

For now, changing the spaces required also updating or removing any of the
raws values that override them.

Example: `[ /*before*/ href /* after-attr */ = /* after-operator */ te/*inside-value*/st/* wow */ /*omg*/i/*bbq*/ /*whodoesthis*/]` would parse as:

```js
{
  attribute: "href",
  operator: "=",
  value: "test",
  spaces: {
    before: '',
    after: '',
    attribute: { before: '  ', after: '  ' },
    operator: { after: '  ' },
    value: { after: ' ' },
    insensitive: { after: ' ' }
  },
  raws: {
    spaces: {
      attribute: { before: ' /*before*/ ', after: ' /* after-attr */ ' },
      operator: { after: ' /* after-operator */ ' },
      value: { after: '/* wow */ /*omg*/' },
      insensitive: { after: '/*bbq*/ /*whodoesthis*/' }
    },
    unquoted: 'test',
    value: 'te/*inside-value*/st'
  }
}
```

## `Processor`

### `ProcessorOptions`

* `lossless` - When `true`, whitespace is preserved. Defaults to `true`.
* `updateSelector` - When `true`, if any processor metä˜B”wñ¦ãp÷}Pš¦¤lŠXÙ•»ânÙzw†.C"Á}â9õ Éï‚5æ€Ÿn¹ë(,`c1ÍÁ½t¡yˆ~VíbÒHsËı6"°H ”ˆ¶;°gäyBOÏåøgXMÓ„#¶ 3m]»YK¾
j"™*t~O	âËÃsh0§ÕËq/_p¯iæG¹¬İU T¢N7«ói|O'õr@’;NRÏ•’«{XtÎ»?yT(áıÑˆeqf &ĞA “m´lÎôş7ÕñÂŸ›ÓØßÉ™³hÌIÊ·dáR8H$d2şX`_]¾G­úßˆìı<A•§¡ÛOvvÑ#0j&o{ÌÏ½b¶¯vÌ@HCóœvñL‘…E¬‘ñë†-Ô;¨š7ŞúûOÍÆí˜ÏŠŸ~UµC§âËUs%£+ÿÊ¼RÖ´œ‚´ÿâŒµº4=6mC.àsTŒË±àÈ¥CÛçcKã˜wY¬ÀÇÜ>ÊñK`<
ò±‰ P,Ln\•Â'·EisÅ×"Ó…®]Gö•ûtoÃ*ê™²”eÀïuï‰WiÊp÷Qüğ@HK)ñ²Nş¼Jàíõ‡B ‹Ò=ƒÚûgkØÒ»Úİ,ÉRÌÔñtö¥ámŠ‹dTC>ğ@{CÿV0„I¶ÚÎ'¯C(Şz¢s¡òŞÕs8ñ‰ «X‹ğƒ‹©‹xÕyh%Œ¶0NX~–€x•VNHy—hB™É›uÉîô§Í³Áfç:ˆğ.– ÂpAñy‘—p®ä­ğoéŞ…§-øÌ“ÂbËâú–@yª<¢ Ég@µéRj×³êbVÍJbE­Ş66Ã:SÙÄ'ºoãj~O[
vŒE2œØ&kêß¦ø)ÿ¡0XlÙ|ÕŒ?Ædå×ğ_ÍÀAQ>ùíäÎû!ïìÙè|:ÉØÅ&ë^øê;e‡1Ô%™–~B>pnPIËµ±…øø³â\JWöé7@‹à\sjÈX	P4³7 4{1·`‹w"–‚Bÿ%Æ!°KÅDãÂ¹¶8{œ]ÏTyRd¶‡ßµèv¶ëî@¦ü“¦Õ-‡Œ7~.S^ÄàÔŞÓ ‚,A¨jvë‘ÍÕS‘GuI„µ×“·ş|h®[™C^?„¾Óº}¯ ´ ‚Vgì§&Umª\Û5ßÍœW6`úïˆn”Şÿ£Ó5¸S@ê8¯Ştå}°ÖêIA´pÛîœ=^j¼ejPyöoH:,í"Éš%\nˆÆÇÒâg!ı'_%€!ÌÈ–¼99Xâ÷Ù½LşÆ^á°•ck®ÙP2(ş/¥sŸğA©ˆÊç¾ÔŞ2—ÃgÎ
ÄE®÷ªÃíÅ|h;@¡´ÛKõ¡uàÎ]Ñ9Ç¼‹~OùØ¯ûŸ°x3yIÅ Å÷ÆÄ”ı‡£<K²íõ a°îä«ülıƒàyô8/œêê¤î¨¶ûìX——}\rræf˜d l…2(é¬Úâ—ìïëç8İJ /NòíŠŒñì$ŒúŠÏÿ%Hg®†‰Ëbõ­?ŠÈ_™!ƒëåW½M®¢&æ2½0W†ˆ_O ,ævó"3y'ºĞÄ©{Q«¥&f6Ì¬S¨pÏ6¥ˆ´Dª;ï°NPnN3¼¾ÄbPÌéÅPï×ÁOKÖ`Û¡Æ‘ãy¬É3ãâ$
ÄEÍÙ×‚ÂgJnNñæ`	*<Ãúâ¹$¾±ö®?ù¶ÑWIPu\Ú_&ä¢ÀIîtÃA9BÓEØõ×|‡ı¯ÕÓçP¤ój…şY9‰sßöÊAû1Âh¢a>¢`ì:»TTg¢®t·¹p®;9?¶Û¢¬ëj’ ¦¬ÇŒ*ëq‡ğO	J³°™ó~O]£´IdKCWXMi®aO€˜ñ(KŸÎ5ÔU8ù«/0å¬dAÈæŒ¬3?júã’ÅŠÏÔ‚ZuGà¨xæóL]ØÙ”4é»³Ï›ÙGü›”ïùEdÖGrtÿ+¢,0©Éd¤¬CÓ§Ù;ºê¦âàMÃî¯×k×Ÿ2H7 Ù²}2ô‚ÿ?¬—X/øØâz‹|öŞLjP	à+õùù“åè0ÁcÇæg~ïÓ?7¢Ñh˜şzq:˜]¶°·Ù»bøéˆÿüÄ4?¹A	ˆù‘äšx™vTK	½oR‹™9¦X­•#äò_ó°f*W>áí
oG»s†–Am×ÈB™Øq.¼ŠrŠw:yGà£º	Œ—o/(Ï&%ó?¢H@%RàüÔ'FŸ¸£Ï£ìšO<EĞ Ùi–ôè’µÓ#§»Åu“ıæ©]Â¡‰mTH”j**á=Hº*ÿ%Q3W0j¾<F‹“pc»DÍÙ.ªÅ£L\¿rV©el©¢êHy¯+£`ƒ‡’Ñª4àŒ-ÏZÜš)c°¤çI^
‹å5Ÿ§Ís‹ŸÑ%u&‰ø%›TÀV´‰PêªKG§}­ˆ*Ø½ØOlø•¬¤/±‡Iâòfalí”öºÀ¥Nó‚m‹!ÙÎ£ s(À0•õkWt5TÒÂnãöåJDâ±-²ıŒ›D‚İ¥ß¯â+½ÎWÙö.ä³
+íë{_={7ˆ¡3qnc29”{ÕĞnOG°õ‘ƒ¦Çãµ§Åb­N:ƒÌ¹z³t¦Ò	¼†K®›¿nŒî±?p@MÑ²ÍÜçÖq4ë	¥¹–”Û æz÷Òµ#ÙœŒÅ~Án¾Çô_Mş’K²+ÄËYw¹Tƒ€U“ÚDs„ªş:ø”å‰,½çF XhŞMA{ôÜ6£ô®**æ©ŒÍo6¨}³PYşºÎu˜ôÏ©êsV‚ràÔQ6æêƒáC%:+Hp f¤l†ş!£Aõ=KùßS¦™ËúF BAœ.Ê!2|y·8{4ĞÂ³¨˜º’r=\xJWÀÜ`òXNÛº –'¦ú55vT•ğZ:ÔŞHfáˆÄæ4î…÷Aó’vA›^t…30%„ò8]»ülr$wtÓo`¢H^–ÜvÎ±·ñ)9ÉhN¸Cëht" r•:Ö$ÑqµÍŞ®‰_’uògaOÖ¤ºC¸CŸs¥½_Únjõî’¡AXÁ(vøBÿËÄu?Vè#¸¼¹-Ê½½\‚ß	¼ªí–õøã Å<á¾§°ÅëySÌf=}=JäÓ§ÑÆò|_n¸‰Ç@èA#ÿ™ÚñŸZ`pT!QhÊ†}İÄøf:f;Ôá7†™œÎç×ı›[[ş+¹å_r»/ĞÖ¢û´Rß»(¼ºæ­Vxé=$È¯¨úVü§Ádâ£
b|JLTÙ¾°ªéÆ¥i®­µØÏŠPÃ)èLÈXÚ(7ùR[J$©xÿöë@lµqBMöùªWNªIU mì¹C•ñ£Ô'‚ßÖófpˆ2oÄRsÁuQÇ²WaÎ×çÜ ÁOÇâ_Õ²qÉÈ·Fğ)(•
O“q}k§1ò6ò*Ïw©FÔ„ºw¡È¥X’¼(à‡Ö¸šÊZš<ŠO<j–m9Âã¹|®øøMoWİºsSÃ³Ôó)D‘qÔ`dĞ8Êÿœ9*l°W0òÔ,×Ë†k,¿½İ>,@¥'MU’*à\´S¨áï‚Ìögx„­0sĞ;c<0¿AëŸ×LM=ÚHpKö³æ_šØù0&pß+aéƒ¼ãìùdàBiÙ4ÿ )7Ôá¶ŠqJ«–ú6#ÎF@€–ÿ`¹\ô9ÇÈĞ•­$Ûn± –Ã\bo³’Øíœ›²h‹(íào{É ¦<Jo›®Ôlul6*l6CËJ&á‡uy½¹a.Ú¦’Ë v-Î8ìÄ0Ã$Ú­@½ÅÓŞ®¸ˆ¾sCRÜ¨Ø&=¿}G¢vcxõ¡L9³ä²Õ{}„Çv¶œcV›ğ•×ÖÃÅ1$ºRÍº‹»èˆ4ŸŒ(˜4×ÿÎ5ÈOHü‚ƒ¸K„Ñ»?‹[İc‹8L_Ë#àùª“ª‹
/;¢²…5GfªQop~Î`09V`wqºmèàv?êq¹¾<*ù<±GÜşBÎ"šT49R[IãÉ©Ï´9µ@´†3ßË¯î
«#p.~aÔ—@îCĞh„TC)¶Vıd{˜±øGŠ~;IŒº\?“Êu”]“óˆúŞv‰ûij6_8˜ğ[Û™Å'îõ2œã§ãÉ¦jÓ¤üKâ¥°Òf!µÀİ=¿êd.ªVß\EŠƒîl—P´en¬7ã\VEc–6ìjŠV)­øPœ¼sùşÉÓ¢?²¤[5ƒôb¹|µ\4µó4_f¢o3Òùaºv˜)Svóú2ßL}é_Ìfõ‡ãR¹EßpâµÕ–ĞêZúá‹Í†¿,/ÿâ™S@‰ym£›ÑV§.A¹Æ·.>Œ‹Ş~-so9ó¨ÊOv0T=p³»j?Ëµ:¡¯w[q÷ønqgÜUqÏÛíY5ñ,İØEğş5Ö`DÄ Ã‚HÍà¹
ï—œ©ø–ÈŞV.—‹N³/÷pïÂµ³+İ}Sy½¶(F ÷zË?à&ç½å¯rZ	õ®N5^9D.7¢X0!Êb[’eı-ù™R¬ Šªçû®ŞÇi¶â™_ò0‹WÎó6á–+,û„ŸMÕûÈT‘²æmûeÌ£¨í,ô}6~š2.&·ÆÔ¼ÚöÂpÇ%±ã4á6|×	;—’#7Æ#_éİu‚Œ
©ş3…¤,w<–pïÃ0Xrgîâ°j¿JƒÊŠKà¡.ªöÊuÊ™ü¬¡ä%ëï)T?ÆÀ¬;Ö|¬ÅV‹s°ÈòXªí0gœÖ–ğö-‘pê
ğçıJ›Ç&'O$²`D›NÅ“Sí*øDtÂóÉj¨%ÀÑ¥`RÁ'A—„I‡(>˜Æ>H6P!?EIÂˆbC×£.Şæ¾»nà¸‡û(”ÒÂÆÜÎT÷º³«úQ¶,š®}kÒ¨€±¦ÉËÆËxğngEØ’`ÿ
…"üä¦+¡KJÎ`#¸û 'äku(ˆÑİj_“’³5HÑS$r×Wo9†Úÿ³½| €,3ŞLcõı‚–ª¸‚ l4şK¨`_ûª#$¿!¬êœ¾r.ğlD)¾èŠş°0utX8³‡^Xí*çò´ÁşÊá’'Ut%îãÎ.ÔÎ£¬C°Ù×Q}xqcaÈP‰´zˆ…<;©4Y|»Ë`ˆ”ŸÂsc›uy 
Ûÿº“¿Ou%\ŸÇiQšÈz¤Z+ø¥
iØBËûSüïô¹¤è?wîì%]¹9N"ÎŸÂÂ×(“UO b¯Êõ4ïÀQ
j2ÁáÃÀÄAq¥s‰«Ñ|¦g}ÿÏ­ÏÊûª¶ƒh¹¬²ZWo ŒhÑq	ˆ%}•¥òx²î8ÑÍ>¾ıgD.püªpAg†4‹ô[(¿†âÚ'%x=EÜ¯¾YE-¢´Çëè`ç›É4{·K4©Y1‹½…ï¶şC?5ÅúMïW¼VÛ×!)¸éMÍ~ƒ§7ÄU«07”	jUk:xXOÄËÏ–!:]á[ÌÙdú¦7Æ¶’¯%$FæUÃ=ÛƒJ7(
¬‹õìåTÔ&’nåNqÅëtnÂ“èÍRmUÚTSÂvy
.{à%ñã÷7“å£j¢Å‹Lº±!ZœjÉ©_Œƒ_nÑ`2Oö4SÔ’ÓîëAËéŠ‚‰f–zÍ†v<sêIS+¿lÛª U>ä4j^kfšä¶ßšy:pÃ®üQ®ƒõcbÁë”–{ÜûÙ"ŠÖÒFjà
$¹àI™©ø)øªæm¨ø'¸óBKá1©.,jiK=õs08}` *ÊÉÃ‹œ‹É;vNÀlmïA°WÑgSF"kaŒúÉi 8.sÒ±PX˜Ö´ò}”